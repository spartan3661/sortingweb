<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sorting Algorithm Visualizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        canvas {
            border: 1px solid black;
            margin-top: 20px;
        }
        .control-panel {
            margin-top: 20px;
        }
    </style>
</head>
<body>

<h1>Sorting Algorithm Visualizer</h1>

<!-- Form for user input -->
<div class="control-panel">
    <form id="array-form">
        <label for="array-size">Enter array size:</label>
        <input type="number" id="array-size" min="1">
        <button type="submit">Generate Random Array</button>
        <label for="delay-input">Delay (ms):</label>
        <input type="number" id="delay-input" value="100">
    </form>

    <!-- Dropdown for selecting sorting algorithm -->
    <select id="algorithm-select">
        <option value="insertSort">Insertion Sort</option>
        <option value="bubbleSort">Bubble Sort</option>
        <option value="quickSort">Quick Sort</option>
        <option value="mergeSort">Merge Sort</option>
        <option value="heapSort">Heap Sort</option>
        <option value="bogoSort">Bogo Sort</option>
        <option value="miracleSort">Miracle Sort</option>

        <!-- Add more options here -->
    </select>
    <button onclick="runSelectedAlgorithm()">Run Selected Algorithm</button>
</div>

<!-- Canvas for drawing bars -->
<canvas id="sortingCanvas" width="800" height="400"></canvas>


<!-- JavaScript logic -->
<script>
    const canvas = document.getElementById('sortingCanvas');
    const ctx = canvas.getContext('2d');

    let array = [];

    // Draw bars according to the array
    function drawBars(highlightIndex = -1, highlightIndex2 = -1) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const barWidth = canvas.width / array.length;

        // Find the maximum value in the array to normalize heights
        const maxValue = Math.max(...array);

        for (let i = 0; i < array.length; i++) {
            const value = array[i];
            const x = i * barWidth;

            // Normalize the height of the bar
            const height = (value / maxValue) * canvas.height;

            // Change color if this bar is being moved
            ctx.fillStyle = (i === highlightIndex || i === highlightIndex2) ? 'red' : 'black';

            ctx.fillRect(x, canvas.height - height, barWidth, height);
        }
    }

    // Generate a random array
    function generateRandomArray(size) {
        // Create an array from 1 to 'size'
        array = Array.from({ length: size }, (_, i) => i + 1);

        // Shuffle the array
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        drawBars();
    }

    // Event listener for form
    document.getElementById('array-form').addEventListener('submit', function(e) {
        e.preventDefault();
        const arraySize = document.getElementById('array-size').value;
        generateRandomArray(arraySize);
    });

    // Asynchronous Heap Sort function
    async function runHeapSort() {
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        const delayValue = parseInt(document.getElementById('delay-input').value) || 100;
        const n = array.length;

        // Build a max heap
        for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
            await heapify(array, n, i, delayValue);
        }

        // Extract elements one by one
        for (let i = n - 1; i > 0; i--) {
            [array[0], array[i]] = [array[i], array[0]]; // Move the root to the end
            drawBars(0, i);
            await delay(delayValue);

            await heapify(array, i, 0, delayValue);
        }
    }
    async function heapify(array, n, i, delayValue) {
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        let largest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;

        if(left < n && array[left] > array[largest]) {
            largest = left;
        }

        // If right child exists and is greater than the largest so far
        if (right < n && array[right] > array[largest]) {
            largest = right;
        }
        // If largest is not root
        if (largest !== i) {
            [array[i], array[largest]] = [array[largest], array[i]];  // Swap
            drawBars(i, largest);
            await delay(delayValue);
            await heapify(array, n, largest, delayValue);
        }
    }


    // Stub functions for sorting algorithms
    // Asynchronous Bubble Sort function
    async function runBubbleSort() {
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        // Get the delay value from the input
        const delayValue = parseInt(document.getElementById('delay-input').value) || 100;

        const n = array.length;

        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n - i - 1; j++) {
                // Highlight the bars being compared
                drawBars(j, j + 1);

                if (array[j] > array[j + 1]) {
                    // Swap
                    [array[j], array[j + 1]] = [array[j + 1], array[j]];
                }

                await delay(delayValue); // Wait for the user-specified delay

                // Redraw bars after swapping
                drawBars();
            }
        }
    }

    async function runInsertionSort() {
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        // Get the delay value from the input
        const delayValue = parseInt(document.getElementById('delay-input').value) || 100;

        const n = array.length;
        let i, key, j;

        for (let i = 1; i < n; i++) {
            // Highlight the bars being compared
            drawBars(j, j + 1);
            key = array[i];
            j = i - 1;
            while( j>= 0 && array[j] > key) {
                array[j+1] = array[j];
                j=j-1;
            }
            array[j+1] = key;


            await delay(delayValue); // Wait for the user-specified delay

            // Redraw bars after swapping
            drawBars();

        }

    }
    // Asynchronous Merge Sort function
    async function runMergeSort(array, start = 0, end = array.length - 1) {
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
        const delayValue = parseInt(document.getElementById('delay-input').value) || 100;

        if (start >= end) return;
        const mid = Math.floor((start + end) / 2);

        await runMergeSort(array, start, mid);
        await runMergeSort(array, mid + 1, end);

        let i = start;
        let j = mid + 1;
        let temp = [];

        while (i <= mid && j <= end) {
            if (array[i] < array[j]) {
                temp.push(array[i]);
                i++;
            } else {
                temp.push(array[j]);
                j++;
            }
        }

        while (i <= mid) {
            temp.push(array[i]);
            i++;
        }

        while (j <= end) {
            temp.push(array[j]);
            j++;
        }

        for (let k = 0; k < temp.length; k++) {
            array[start + k] = temp[k];
        }

        drawBars();
        await delay(delayValue);
    }

    // Miracle Sort lol
    async function runMiracleSort() {
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
        const delayValue = parseInt(document.getElementById('delay-input').value) || 100;
        alert("Wait for a miracle to happen!");

        await delay(10000); // Wait for 10 seconds

        array.sort((a, b) => a - b);
        drawBars();
        alert("The miracle has happened!");
    }


    // Asynchronous Bogo Sort function
    async function runBogoSort() {
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
        const delayValue = parseInt(document.getElementById('delay-input').value) || 100;

        const isSorted = arr => arr.every((v, i, a) => !i || a[i - 1] <= v);

        while (!isSorted(array)) {
            // Shuffle the array
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            drawBars();
            await delay(delayValue);
        }
    }
    // Asynchronous Quick Sort function
    async function runQuickSort(low, high) {
        if (low < high) {
            const pi = await partition(low, high);

            await runQuickSort(low, pi - 1);
            await runQuickSort(pi + 1, high);
        }
    }

    // Function to partition the array and return the partition index
    async function partition(low, high) {
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        const delayValue = parseInt(document.getElementById('delay-input').value) || 100;

        let pivot = array[high];
        let i = low - 1;

        for (let j = low; j <= high - 1; j++) {
            // Highlight the bars being compared
            drawBars(j, high);

            if (array[j] < pivot) {
                i++;
                [array[i], array[j]] = [array[j], array[i]];
                await delay(delayValue);
                drawBars(i, j);
            }

            await delay(delayValue);
        }

        [array[i + 1], array[high]] = [array[high], array[i + 1]];
        await delay(delayValue);
        drawBars(i + 1, high);
        return (i + 1);
    }

    // Event listener for form
    document.getElementById('array-form').addEventListener('submit', function(e) {
        e.preventDefault();
        const arraySize = document.getElementById('array-size').value;
        generateRandomArray(arraySize);
    });

    // Function to resize the canvas and redraw bars
    function resizeCanvas() {
        canvas.width = window.innerWidth * 0.8; // 80% of window width
        canvas.height = window.innerHeight * 0.6; // 60% of window height
        drawBars();
    }

    // Event listener for window resize
    window.addEventListener('resize', resizeCanvas);

    // Initial canvas resize
    resizeCanvas();


    // Function to run the selected algorithm
    function runSelectedAlgorithm() {
        const algorithm = document.getElementById('algorithm-select').value;

        if (algorithm === 'bubbleSort') {
            runBubbleSort();
        } else if (algorithm === 'quickSort') {
            runQuickSort(0, array.length - 1);
        } else if (algorithm === 'insertSort') {
            runInsertionSort();
        } else if (algorithm === 'mergeSort') {
            runMergeSort(array);
        } else if (algorithm === 'heapSort') {
            runHeapSort();
        } else if (algorithm === 'bogoSort') {
            runBogoSort();
        } else if (algorithm === 'miracleSort') {
            runMiracleSort();
        }
    }
</script>
</body>
</html>
